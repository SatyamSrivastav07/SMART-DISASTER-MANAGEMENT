import React, { createContext, useContext, useState, useEffect } from 'react';
import { sensorsAPI, locationAPI } from '../services/api';

const SensorDataContext = createContext();

export const useSensorData = () => {
  const context = useContext(SensorDataContext);
  if (!context) {
    throw new Error('useSensorData must be used within a SensorDataProvider');
  }
  return context;
};

export const SensorDataProvider = ({ children }) => {
  const [sensorData, setSensorData] = useState({
    seismic: {
      magnitude: 0,
      depth: 0,
      location: { lat: 28.6692, lng: 77.4538 },
      timestamp: new Date()
    },
    weather: {
      temperature: 25,
      humidity: 60,
      windSpeed: 10,
      windDirection: 180,
      pressure: 1013,
      visibility: 10,
      timestamp: new Date()
    },
    airQuality: {
      aqi: 85,
      pm25: 35,
      pm10: 45,
      co: 0.8,
      no2: 25,
      o3: 60,
      so2: 8,
      timestamp: new Date()
    },
    waterLevel: {
      level: 3.2,
      flowRate: 45,
      temperature: 22,
      ph: 7.2,
      timestamp: new Date()
    },
    traffic: {
      congestionLevel: 35,
      avgSpeed: 25,
      incidents: [],
      timestamp: new Date()
    },
    infrastructure: {
      powerGrid: 98,
      waterSupply: 95,
      communication: 99,
      transportation: 87,
      timestamp: new Date()
    }
  });

  const [isOnline, setIsOnline] = useState(true);
  const [lastUpdate, setLastUpdate] = useState(new Date());
  const [userLocation, setUserLocation] = useState(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  // ✅ Get user location once on mount
  useEffect(() => {
    const getUserLocation = async () => {
      try {
        const position = await locationAPI.getCurrentPosition();
        setUserLocation({
          lat: position.lat,
          lon: position.lon,
          accuracy: position.accuracy
        });
        setError(null);
      } catch (err) {
        console.warn('Could not get user location, using default:', err.message);
        setUserLocation({
          lat: 28.6692, // Ghaziabad default
          lon: 77.4538,
          accuracy: null
        });
      }
    };

    getUserLocation();
  }, []);

  // ✅ Fetch real data from API
  const fetchRealSensorData = async () => {
    try {
      if (!userLocation) return;

      setLoading(true);
      const response = await sensorsAPI.getCurrentReadings(userLocation.lat, userLocation.lon);

      if (response.readings) {
        const updatedData = { ...sensorData };

        Object.keys(response.readings).forEach(sensorType => {
          const readings = response.readings[sensorType];
          if (readings && readings.length > 0) {
            const latest = readings[0];

            switch (sensorType) {
              case 'seismic':
                updatedData.seismic = {
                  ...updatedData.seismic,
                  magnitude: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              case 'temperature':
                updatedData.weather = {
                  ...updatedData.weather,
                  temperature: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              case 'humidity':
                updatedData.weather = {
                  ...updatedData.weather,
                  humidity: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              case 'wind_speed':
                updatedData.weather = {
                  ...updatedData.weather,
                  windSpeed: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              case 'pressure':
                updatedData.weather = {
                  ...updatedData.weather,
                  pressure: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              case 'air_quality':
                updatedData.airQuality = {
                  ...updatedData.airQuality,
                  aqi: latest.value,
                  timestamp: new Date(latest.timestamp)
                };
                break;
              default:
                break;
            }
          }
        });

        setSensorData(updatedData);
        setLastUpdate(new Date());
      }

      setLoading(false);
    } catch (err) {
      console.error('Error fetching sensor data:', err.message);
      setError(err.message);
      setLoading(false);
    }
  };

  // ✅ Poll API every 10s for live updates
  useEffect(() => {
    if (!userLocation) return;
    fetchRealSensorData();
    const interval = setInterval(fetchRealSensorData, 10000);
    return () => clearInterval(interval);
  }, [userLocation]);

  // ✅ Simulate network status
  useEffect(() => {
    const interval = setInterval(() => {
      setIsOnline(Math.random() > 0.05); // 95% uptime
    }, 10000);
    return () => clearInterval(interval);
  }, []);

  // ✅ Helper: get sensor status
  const getSensorStatus = (sensorType, value) => {
    switch (sensorType) {
      case 'seismic':
        if (value >= 4.0) return 'critical';
        if (value >= 3.0) return 'warning';
        return 'normal';
      case 'weather':
        if (value >= 40) return 'critical';
        if (value >= 25) return 'warning';
        return 'normal';
      case 'airQuality':
        if (value >= 200) return 'critical';
        if (value >= 100) return 'warning';
        return 'normal';
      case 'waterLevel':
        if (value >= 8) return 'critical';
        if (value >= 6) return 'warning';
        return 'normal';
      default:
        return 'normal';
    }
  };

  // ✅ Helper: generate fake historical data for charts
  const getHistoricalData = (sensorType, timeRange = '24h') => {
    const dataPoints = [];
    const now = new Date();
    const interval = timeRange === '24h' ? 3600000 : 300000;
    const points = timeRange === '24h' ? 24 : 288;

    for (let i = points; i >= 0; i--) {
      const timestamp = new Date(now.getTime() - i * interval);
      const value = Math.random() * 100;
      dataPoints.push({
        timestamp,
        value,
        status: getSensorStatus(sensorType, value)
      });
    }
    return dataPoints;
  };

  const value = {
    sensorData,
    isOnline,
    lastUpdate,
    loading,
    error,
    fetchRealSensorData,
    getSensorStatus,
    getHistoricalData
  };

  return (
    <SensorDataContext.Provider value={value}>
      {children}
    </SensorDataContext.Provider>
  );
};
