const API_BASE_URL = process.env.REACT_APP_API_URL || 'http://localhost:5000/api';

// Helper function to get auth token
const getAuthToken = () => {
  return localStorage.getItem('authToken');
};

// Helper function for authenticated requests
const authHeaders = () => {
  const token = getAuthToken();
  return token ? { 'Authorization': `Bearer ${token}` } : {};
};

// Helper function for API calls
const apiCall = async (endpoint, options = {}) => {
  const url = `${API_BASE_URL}${endpoint}`;
  const config = {
    headers: {
      'Content-Type': 'application/json',
      ...authHeaders(),
      ...options.headers
    },
    ...options
  };

  const response = await fetch(url, config);
  const data = await response.json();

  if (!response.ok) {
    throw new Error(data.message || 'API request failed');
  }

  return data;
};

// Authentication API
export const authAPI = {
  register: (userData) => apiCall('/auth/register', {
    method: 'POST',
    body: JSON.stringify(userData)
  }),

  login: (credentials) => apiCall('/auth/login', {
    method: 'POST',
    body: JSON.stringify(credentials)
  }),

  getProfile: () => apiCall('/auth/profile'),

  updateProfile: (userData) => apiCall('/auth/profile', {
    method: 'PATCH',
    body: JSON.stringify(userData)
  }),

  changePassword: (passwords) => apiCall('/auth/change-password', {
    method: 'PATCH',
    body: JSON.stringify(passwords)
  }),

  logout: () => {
    localStorage.removeItem('authToken');
    localStorage.removeItem('userData');
    return Promise.resolve();
  }
};

// Alerts API
export const alertsAPI = {
  getAlerts: (params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    return apiCall(`/alerts?${queryString}`);
  },

  createAlert: (alert) => apiCall('/alerts', {
    method: 'POST',
    body: JSON.stringify(alert)
  }),

  acknowledgeAlert: (alertId) => apiCall(`/alerts/${alertId}/acknowledge`, {
    method: 'PATCH'
  }),

  resolveAlert: (alertId, resolution) => apiCall(`/alerts/${alertId}/resolve`, {
    method: 'PATCH',
    body: JSON.stringify({ resolution })
  }),

  assignTeam: (alertId, teamId) => apiCall(`/alerts/${alertId}/assign-team`, {
    method: 'PATCH',
    body: JSON.stringify({ teamId })
  }),

  getAlertStats: () => apiCall('/alerts/stats/overview')
};

// Sensors API
export const sensorsAPI = {
  getSensors: (params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    return apiCall(`/sensors?${queryString}`);
  },

  getCurrentReadings: (lat, lon) => {
    const params = lat && lon ? `?lat=${lat}&lon=${lon}` : '';
    return apiCall(`/sensors/readings/current${params}`);
  },

  getLocationData: (lat, lon) => apiCall(`/sensors/location/${lat}/${lon}`),

  getSensorHistory: (sensorId, hours = 24) => 
    apiCall(`/sensors/${sensorId}/history?hours=${hours}`),

  getSensorStats: () => apiCall('/sensors/stats/overview')
};

// Teams API
export const teamsAPI = {
  getTeams: (params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    return apiCall(`/teams?${queryString}`);
  },

  assignTeam: (teamId, alertId, priority = 'medium') => apiCall(`/teams/${teamId}/assign`, {
    method: 'PATCH',
    body: JSON.stringify({ alertId, priority })
  }),

  updateTeamStatus: (teamId, status) => apiCall(`/teams/${teamId}/status`, {
    method: 'PATCH',
    body: JSON.stringify({ status })
  }),

  updateTeamLocation: (teamId, location) => apiCall(`/teams/${teamId}/location`, {
    method: 'PATCH',
    body: JSON.stringify(location)
  }),

  getTeamStats: () => apiCall('/teams/stats/overview')
};

// Disaster Reports API
export const reportsAPI = {
  getReports: (params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    return apiCall(`/reports?${queryString}`);
  },

  createReport: async (reportData) => {
    const formData = new FormData();
    
    // Add text fields
    Object.keys(reportData).forEach(key => {
      if (key !== 'images') {
        if (typeof reportData[key] === 'object') {
          formData.append(key, JSON.stringify(reportData[key]));
        } else {
          formData.append(key, reportData[key]);
        }
      }
    });

    // Add images
    if (reportData.images && reportData.images.length > 0) {
      reportData.images.forEach(image => {
        formData.append('images', image);
      });
    }

    const response = await fetch(`${API_BASE_URL}/reports`, {
      method: 'POST',
      headers: {
        ...authHeaders()
      },
      body: formData
    });

    const data = await response.json();
    if (!response.ok) {
      throw new Error(data.message || 'Failed to create report');
    }

    return data;
  },

  updateReportStatus: (reportId, status, adminNotes) => apiCall(`/reports/${reportId}/status`, {
    method: 'PATCH',
    body: JSON.stringify({ status, adminNotes })
  }),

  addResponse: (reportId, message, type = 'update') => apiCall(`/reports/${reportId}/responses`, {
    method: 'POST',
    body: JSON.stringify({ message, type })
  }),

  getUserReports: (params = {}) => {
    const queryString = new URLSearchParams(params).toString();
    return apiCall(`/reports/my/reports?${queryString}`);
  },

  getReportStats: () => apiCall('/reports/stats/overview')
};

// Training API
export const trainingAPI = {
  getModules: () => apiCall('/training/modules'),
  
  getModule: (moduleId) => apiCall(`/training/modules/${moduleId}`),
  
  updateProgress: (moduleId, progress, completed = false) => apiCall(`/training/modules/${moduleId}/progress`, {
    method: 'PATCH',
    body: JSON.stringify({ progress, completed })
  }),
  
  getStats: () => apiCall('/training/stats')
};

// Location Services
export const locationAPI = {
  getCurrentPosition: () => {
    return new Promise((resolve, reject) => {
      if (!navigator.geolocation) {
        reject(new Error('Geolocation is not supported'));
        return;
      }

      navigator.geolocation.getCurrentPosition(
        (position) => {
          resolve({
            lat: position.coords.latitude,
            lon: position.coords.longitude,
            accuracy: position.coords.accuracy
          });
        },
        (error) => {
          reject(new Error('Unable to get location: ' + error.message));
        },
        {
          enableHighAccuracy: true,
          timeout: 10000,
          maximumAge: 300000 // 5 minutes
        }
      );
    });
  },

  watchPosition: (callback, errorCallback) => {
    if (!navigator.geolocation) {
      errorCallback?.(new Error('Geolocation is not supported'));
      return null;
    }

    return navigator.geolocation.watchPosition(
      (position) => {
        callback({
          lat: position.coords.latitude,
          lon: position.coords.longitude,
          accuracy: position.coords.accuracy,
          timestamp: new Date(position.timestamp)
        });
      },
      (error) => {
        errorCallback?.(new Error('Location watch error: ' + error.message));
      },
      {
        enableHighAccuracy: true,
        timeout: 15000,
        maximumAge: 60000 // 1 minute
      }
    );
  }
};

// Utility functions
export const utils = {
  // Format date for display
  formatDate: (date) => {
    return new Date(date).toLocaleDateString('en-IN', {
      year: 'numeric',
      month: 'short',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    });
  },

  // Calculate distance between two coordinates
  calculateDistance: (lat1, lon1, lat2, lon2) => {
    const R = 6371; // Earth's radius in km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
      Math.sin(dLon / 2) * Math.sin(dLon / 2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  },

  // Get severity color
  getSeverityColor: (severity) => {
    const colors = {
      low: 'text-yellow-600 bg-yellow-100',
      medium: 'text-orange-600 bg-orange-100',
      high: 'text-red-600 bg-red-100',
      critical: 'text-red-800 bg-red-200'
    };
    return colors[severity] || colors.medium;
  },

  // Debounce function
  debounce: (func, wait) => {
    let timeout;
    return function executedFunction(...args) {
      const later = () => {
        clearTimeout(timeout);
        func(...args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }
};

export default {
  authAPI,
  alertsAPI,
  sensorsAPI,
  teamsAPI,
  reportsAPI,
  trainingAPI,
  locationAPI,
  utils
};